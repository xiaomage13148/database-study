# 第六章 索引的数据结构

## 6.1 为什么使用索引

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911231735.png)

假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911231818.png)

## 6.2 索引概述

> 索引（Index）是帮助MySQL高效获取数据的数据结构

索引的本质：索引是`数据结构`。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法

## 6.3 索引优缺点

### 优点

1. 类似大学图书馆建书目索引，提高数据检索的效率，降低 <font color="green">数据库的IO成本</font> ，这也是创建索引最主 要的原因
2. 通过创建唯一索引，可以保证数据库表中每一行 <font color="green">数据的唯一性</font>
3. 在实现数据的 参考完整性方面，可以 `加速表和表之间的连接` 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度
4. 在使用分组和排序子句进行数据查询时，可以显著 `减少查询中分组和排序的时 间 `，降低了CPU的消耗

### 缺点

1. <font color="yellow">创建索引和维护索引</font>要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加
2. 索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸
3. 虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度

## 6.4 设计索引

### 建表

```mysql
CREATE TABLE `test_tb_02_index`
(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY (c1)
) ROW_FORMAT = Compact;
```

- 新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键
- 这个表使用 <font color="gree">Compact 行格式</font>来实际存储记录的

### test_tb_02_index表的行格式示意图

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220629165006.png)

- record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、1 表示 目录项记录
- next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁
- 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 
- 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息

<font color="red">将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果</font>

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911233058.png)

将一些记录放到页里的示意图：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911233155.png)

### 一个简单的索引设计方案

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？

因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。

所以如果 我们想快速的定位到需要查找的记录在哪些数据页 中该咋办？

我们可以<font color="#7FFF00">为快速定位记录所在的数据页而 建立一个目录</font> ，建这个目录必须完成下边这些事：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
- 给所有的页建立一个目录项

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220629171117.png)

以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了

比如：查找主键值为 20 的记录，具体查找过程分两步：

1. 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9
2. 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录

这个目录有一个别名，称为 索引

### InnoDB中的索引方案

#### 迭代1次：目录项纪录的页

我们把前边使用到的目录项放到数据页中的样子就是这样：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911233929.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录 和普通的 用户记录 的

不同点：

- 目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0
- 目录项记录只有 <font color="#7FFF00">主键值和页的编号</font> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 很 多列 ，另外还有InnoDB自己添加的隐藏列

相同点：

- 两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9
2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录

#### 迭代2次：多个目录项纪录的页

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911234403.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

1. 为存储该用户记录而新生成了 页31
2. 因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步 骤，以查找主键值为 20 的记录为例：

1. 确定 目录项记录页，我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为<font color="gree">页30表示的目录项的主键值的 范围是 [1, 320) </font>，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中
2. 通过目录项记录页 确定用户记录真实所在的页
3. 在真实存储用户记录的页中定位到具体的记录

#### 迭代3次：目录项记录页的目录页

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220911234953.png)

如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录

###  B+Tree（`待完成`）

。。。。未完续贷。。。

## 6.5 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引

### 聚簇（聚集）索引

#### 特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - <font color="#00FF00">页内 的记录是按照主键的大小</font>顺序排成一个 单向链表
   - 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表
   - 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表
2. B+树的 叶子节点 存储的是完整的用户记录：
   - 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）

#### 优点：

- 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快
- 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作`

#### 缺点：

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新
- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据

### 二级索引（辅助索引、非聚簇索引）

#### 回表概念（`待完成`）

回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

<font color="gree">为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</font>

。。。。待完成

#### 详细参考

- [(52条消息) 聚簇索引和非聚簇索引到底有什么区别？_Linux小百科的博客-CSDN博客_聚簇索引和非聚簇索引的区别](https://blog.csdn.net/yaxuan88521/article/details/125464584)

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序
- 在记录的c2列相同的情况下，采用c3列进行排序

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

- 建立 联合索引 只会建立如上图一样的1棵B+树。
- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树

###  InnoDB的B+树索引的注意事项

- 根页面位置万年不动
- 内节点中目录项记录的唯一性
- 一个页面最少存储2条记录

### MyISAM中的索引方案

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的

<font color="#FCE6C9">Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引</font>

不同点：

MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 

#### MyISAM索引的原理

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912154851.png)

#### 参考

- [(52条消息) InnoDB和MyISAM索引_weixin_38744693的博客-CSDN博客_innodb和myisam的索引](https://blog.csdn.net/weixin_38744693/article/details/113856946)

### MyISAM 与 InnoDB对比

<font color="yellow" face="黑体">MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</font>小结两种引擎中索引的区 别：

1. 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着`MyISAM中建立的索引相当于全部都是 二级索引 `
2. InnoDB的`数据文件本身就是索引文件`，而`MyISAM索引文件和数据文件是 分离的` ，索引文件仅保存数 据记录的地址
3. InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域
4. MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问
5.  <font color="gree">InnoDB要求表 必须有主键 （ MyISAM可以没有 ）</font>。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912155628.png)

### 索引的代价

#### 空间上的代价

<font color="red">每建立一个索引都要为它建立一棵B+树</font>，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间

#### 时间上的代价

每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表

而增、删、改操作可能会对节点和记录的排序造成破坏，所以`存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序`。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿

## 6.6 MySQL数据结构的选择

### 全表遍历

### Hash结构

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912160124.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 `哈希碰撞` ，在数据库中一般采用 <font color="yellow">链 接法</font> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912160241.png)

#### 自适应Hash

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912160241.png)

- 采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率

我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：

```mysql
show variables like '%adaptive_hash_index';
```

### 二叉搜索树

如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的

#### 二叉搜索树的特点

1. 二叉搜索树的特点是对于树中的每个节点X，它的<font color="gree">左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值</font>；

2. 根据这个性质，对一个二叉树进行中序遍历，如果是单调递增的，则可以说明这个树是二叉搜索树

### AVL树

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912161245.png)

针对同样的数据，如果我们把二叉树改成 M 叉树 （M>2）呢？当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912161314.png)

### B-Tree

#### B 树的结构

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912161408.png)

假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：

- 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；
- 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；
- 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9

你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的

而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 <font color="gree">只要树的高度足够低，IO次数足够少，就可以提高查询性能 </font>

具体：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912161908.png)

###  B+Tree

#### 一个m阶的B+树具有如下几个特征：

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点
2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

#### 参考

- [(52条消息) 什么是B+树？（详细图解）_初念初恋的博客-CSDN博客_b+树](https://blog.csdn.net/jiang_wang01/article/details/113739230)

### B+ 树和 B 树的差异（`待完成`）

### B+ 树和 B 树相关思考（`待完成`）

1. 为了减少IO，索引树会一次性加载吗？
2. B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO
3. 为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？
4. Hash 索引与 B+ 树索引的区别
5. Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？

### R树

R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种

## 6.7 常见算法的时间复杂度

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220912162317.png)





