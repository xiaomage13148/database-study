# 第十一章 数据库的设计规范

## 11.1 范 式

<font color="#FF6100">在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</font>；

目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：

第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美 范式）

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220913211305.png)

### 11.1.1 键和相关属性的概念

1. 超键：能唯一标识一条记录的属性集叫做超键
2. 候选键：如果超键中不包括多余的属性,那么这个超键就是一个候选键
3. 主键: 用户可以从候选键中选择一个作为主键
4. 外键: 如果数据表R1的某个属性不是R1的主键,而是另一个数据表R2的主键,那么这个属性就是数据表R1的外键
5. 主属性: 包含在任意候选键中的属性都称之为主属性，也就是可以出现在候选键的属性集中的属性都是主属性
6. 非主属性: 与主属性相对,指的是不包含在任何一个候选键中的属性

举例：

这里有两个表：

```mysql
球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team) ：球队编号 | 主教练 | 球队所在地
```

- 超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等
- 候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）
- 主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）
- 外键 ：球员表中的球队编号
- 主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性

### 11.1.2 第一范式(1st NF)

> <font color="#7FFFD4">第一范式要求消除拆分字段至原子字段，即不可再拆分</font>；
>
> 是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性
>
> 属性的原子性是 主观的

举例：

user 表的设计不符合第一范式

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220913212039.png)

- user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求

- 将user_info拆分后如下：

  ![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220913212127.png)

### 11.1.3 第二范式(2nd NF)

> <font color="#7FFFD4">第二范式要求消除部分函数依赖，实现完全函数依赖</font>；
>
> 属性完全依赖于主键，要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识
>
> 1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只 表达一个意思

举例：

```mysql
成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课 程号也不能决定成绩，
所以'(学号，课程号) -> 成绩'就是 '完全依赖关系 '
```

```mysql
# 比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这
# 里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：
(球员编号, 比赛编号) -> (姓名, 年龄, 比赛时间, 比赛场地，得分)
# 但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：
(球员编号) -> (姓名，年龄)
(比赛编号) -> (比赛时间, 比赛场地)
```

对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？

1. 数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次
2. 插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没 法插入
3. 删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉
4. 更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况

### 11.1.4 第三范式(3rd NF)

> <font color="#7FFFD4">第三范式要求消除传递函数依赖</font>
>
> 要求一个数据库表中不包含已在其它表中已包含的非主关键字信息
>
> 符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于 整个键，并且除了键别无他物”

举例：

部门信息表 ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息

员工信息表 ：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介 等与部门有关的信息再加入员工信息表中

```mysql
(部门编号) -> (部门名称、部门简介)
(员工编号) -> (姓名、部门编号、部门名称) # 这里便存在着传递依赖的问题 员工编号 -> 部门编号 -> 部门名称
```

### 11.1.5 反范式化

#### 举例

员工的信息存储在 employees 表 中，部门信息存储在 departments 表 中。通过 employees 表中的 department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：

```mysql
select employee_id,department_name
from employees e join departments d
on e.department_id = d.department_id;
```

如果经常需要进行这个操作，连接查询就会浪费很多时间。`可以在 employees 表中增加一个冗余字段 department_name`，这样就不用每次都进行连接操作了

#### 反范式的新问题

- 存储 `空间变大 `了 

- 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致 
- 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源 
- 在 `数据量小` 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂

### 11.1.6 BCNF(巴斯范式)

<font color="gree">若一个关系达到第三范式，并且它只有一个候选键或者它的每个候选键都是单属性，则该关系自然就达到巴斯范式</font>

我们分析如下表的范式情况：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220913232154.png)

在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性 之间的依赖关系

仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键

- 候选键 ：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为 主键 ，比 如（仓库名，物品名）。 
- 主属性 ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。 
- 非主属性 ：数量这个属性

<font color="yellow">如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断</font>

- 首先，数据表每个属性都是原子性的，符合 1NF 的要求
- 数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品 名）决定数量。因此，数据表符合 2NF 的要求
- 数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求

#### 存在的问题

既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下面的情况：

1. 增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因 此会出现 插入异常
2. 如果仓库更换了管理员，我们就可能会 修改数据表中的多条记录
3. 如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除

即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况

#### 问题解决

首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系， 这样就有可能导致上面的异常情况。因此引入BCNF，`它在 3NF 的基础上消除了主属性对候选键的部分依 赖或者传递依赖关系`

根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：

- 仓库表 ：（仓库名，管理员） 
- 库存表 ：（仓库名，物品名，数量）

这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF

### 11.1.7 第四范式

设R是一个关系模型，D是R上的多值依赖集合。如果D中存在凡多值依赖X->Y时，X必是R的超键，那么称R是第四范式的模式

举例：

比如我们建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的 一组教材，一门课程使用的教材和教师没有关系。

我们建立的关系表如下： 课程ID，教师ID，教材ID；这三列作为联合主键。 为了表述方便，我们用Name代替ID，这样更容易看懂：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220915105058.png)

这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在 `多值依赖` 导致的异常

<font color="gree">假如我们下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么我们就无法在这 个表中维护Course高数和Book英版高数教材的的关系</font>

解决办法是我们把这个多值依赖的表拆解成2个表，分别建立关系。这是我们拆分后的表：

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220915105231.png)

![](https://memory.xiaomage13148.xyz/typeroImage/QQ%E6%88%AA%E5%9B%BE20220915105253.png)

### 11.1.8 第五范式、域键范式

第五范式（又称完美范式）和域键范式（DKNF）

在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式R中的每一个连 接依赖均由R的候选键所隐含，则称此关系模式符合第五范式

函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 语义直接导出 ，而是在 关系连接运算 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。 第五范式处理的是 无损连接问题 ，这个范式基本 没有实际意义 ，因为无损连接很少出现，而且难以察 觉。而域键范式试图定义一个 终极范式 ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小 的，只存在理论研究中

## 11.2 ER模型

<font color="gree">ER 模型中有三个要素，分别是实体、属性和关系</font>

- 实体 ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 `矩形` 来表 示。实体分为两类，分别是 强实体 和 弱实体 。`强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体`
- 属性 ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 `椭圆形 `来表示
- 关系 ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 `菱形` 来表示

可以独立存在 的是实体，不可再分的是属性。也就是说，属性不能包含其他属性

### 关系的类型

在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多

一对一 ：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个 人只能有一个身份证信息，一个身份证信息也只属于一个人

一对多 ：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关 系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系

多对多 ：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系

### ER 模型图转换成数据表

把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：

- 一个 实体 通常转换成一个 数据表
- 一个 多对多的关系 ，通常也转换成一个 数据表
- 一个 1 对 1 ，或者 1 对多 的关系，往往通过表的 外键 来表达，而不是设计一个新的数据表
- 属性 转换成表的 字段 

## 11.3 数据表的设计原则

出数据表设计的一般原则："三少一多"

1. 数据表的个数越少越好
2. 数据表中的字段个数越少越好
3. 数据表中联合主键的字段个数越少越好
4. 使用主键和外键越多越好

<font color="red">注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率</font>

## 11.4 数据库对象编写建议

### 关于库

1. 库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头

2. 库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意

3. 库的名称格式：业务系统名称_子系统名

4. 库名禁止使用关键字（如type,order等）

5. 创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4

   ```mysql
   # 举例
   CREATE DATABASE crm_fund DEFAULT CHARACTER SET 'utf8' ;
   ```

6. 临时库以 tmp_ 为前缀，并以日期为后缀； 备份库以 bak_ 为前缀，并以日期为后缀

### 关于表、列

1. 表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头
2. 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意
3. 表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item
4. 创建表时必须 显式指定字符集 为utf8或utf8mb4
5. 表名、列名禁止使用关键字（如type,order等）
6. 创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB
7. 建表必须有comment
8. 布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled
9. `禁止`在数据库中存储图片、文件等大的二进制数据
10. 核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题
11. 表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题

规范的建表语句：

```mysql
CREATE TABLE user_info (
`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
`user_id` bigint(11) NOT NULL COMMENT '用户id',
`username` varchar(45) NOT NULL COMMENT '真实姓名',
`email` varchar(30) NOT NULL COMMENT '用户邮箱',
`nickname` varchar(45) NOT NULL COMMENT '昵称',
`birthday` date NOT NULL COMMENT '生日',
`sex` tinyint(4) DEFAULT '0' COMMENT '性别',
`short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字',
`user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址',
`user_register_ip` int NOT NULL COMMENT '用户注册时的源ip',
`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE
CURRENT_TIMESTAMP COMMENT '修改时间',
`user_review_status` tinyint NOT NULL COMMENT '用户资料审核状态，1为通过，2为审核中，3为未
通过，4为还未提交审核',
PRIMARY KEY (`id`),
UNIQUE KEY `uniq_user_id` (`user_id`),
KEY `idx_username`(`username`),
KEY `idx_create_time_status`(`create_time`,`user_review_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站用户基本信息';
```

### 关于索引

1. InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新
2. InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE
3. 主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律 使用小写格式，以字段的名称或缩写作为后缀
4. 单个表上的索引个数 不能超过6个
5. 在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面
6. 在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高

### SQL编写

1. 程序端SELECT语句必须指定具体字段名称，禁止写成 *
2. 程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)
3. 除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找
4. SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内
5. 减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的
6. 包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢

## 11.5 推荐

- 建立数据库，构造表时最好使用建模工具进行建库建表的操作



